3.5 days

Java 
Javascript
Database-sql and nosql

Timings
9.30 to 5.30
break:
 Morning and Eve Tea Break- 20 mins
 Lunch - 1 hr
.....................................................................................
				 Java 
.....................................................................................

Java Fundamentals:

What is Java?
 Java is Technology.
 Java technology created at SUN Microsystems at 1989 to solve the problem of 
 Platform(os+hardware) Portablity, with alternate to c and c++.
 if you build software using c/c++, can used where it was created for eg UNIX means  only unix

Java features:
1.no pointers
2.pure object oriented models
3.platform netural
4.easy to learn

How java achives portablity?
  JVM - Java virtual machine - software abstraction for platforms

How to begin with java?
 Java distributed lot of tools

1. Javaprogramming langaugage
2. JDK- Java development Kit
    compilers -javac
    Runtime  - java

Byte code:
  c and c++ source code is compiled, after that we can see compiled code which is written assembly language(which is os spefic)
 java source is compiled after that we can see  compiled code which is written assembly language(byte/class file)(which is not os spefic)


Java Editions:
.............
1.Java Standard Edition - JSE
2.Java Enterprise Edition - JEE
3.Java Micro Edition - JME

Applications of Java:

1.JSE
  Core Language, called java language

2.JEE 
   Buliding Web App,database apps - Microservices
 Servlet
 JSP
 JPA
 JAX-RS/JAX-WS - Webservice
 etc....

Frameworks for java Technology

1.Struts Web Framework - The first jee framework- no more this tech
2.Spring Framework - It is no-1 java development framework
3.Quarkus
4.Vert.x
5.Open Liberty
etc...

Java Versions:

Java 1.0
|
Java 8
|
Java 11
|
Java 18

JDK's
......
There are many vendors offer JDK.

1.Oracle JDK - Commericial JDK for Production, dev free
2.Open JDK - dev + production is free
3.Azul JDK - commericial jdks
4.IBM Jdk
.....................................................................................
			   JDK installation
...................................................................................

>java --version
java 11.0.11 2021-04-20 LTS
Java(TM) SE Runtime Environment 18.9 (build 11.0.11+9-LTS-194)
Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.11+9-LTS-194, mixed mode)
....................................................................................
			 How to write code Apps
....................................................................................

Req:
1.JDK - 11
2.Editors/IDE
a.https://www.eclipse.org/downloads/
b.https://www.jetbrains.com/idea/download/#section=windows -Intellij Idea
c.https://code.visualstudio.com/ - VS Code.
...................................................................................
			  Build Systems
...................................................................................

Build system is tool for creating, managing softwares during dev,test cycles.

Java Build System:

1.Apache ant - First build system for java
2.Maven - Modern build system for java
3.Gradle -https://gradle.org/- Modern build system for java
...................................................................................
			Java 11 Programming language
...................................................................................

 1.Language fundamentals
 2.Object Programming  concepts and Implementation
 3.Exception Handling
 4.Collections Framework
 5.Concurrency and multi threading
 6.Database Programming using JDBC
 7.Functional Programming and java
 8.Lambda 


1.Language fundamentals

Project setup :Maven Project

src/main/java
  Here only we write code

HelloWorld.java

package com.ibm;

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello Java!");
    }
}

After Compilation
HelloWorld.class

ÃŠÃ¾ÂºÂ¾   7 "
  	   
     <init> ()V Code LineNumberTable LocalVariableTable this Lcom/ibm/HelloWorld; main ([Ljava/lang/String;)V args [Ljava/lang/String; 
SourceFile HelloWorld.java      Hello Java!    ! com/ibm/HelloWorld java/lang/Object java/lang/System out Ljava/io/PrintStream; java/io/PrintStream println (Ljava/lang/String;)V !            	   /     *Â· Â±    
                 
   	    	   7     	Â² Â¶ Â±    
   
              	          


We have to run?
java HelloWorld

Modularity:

  breaking the code into files and folders, and organized based on some standards
  In java modularity is implemented via packages.

Modularity:

  breaking the code into files and folders, and organized based on some standards
  In java modularity is implemented via packages.

What is Package?

  logical and physical organization of java source and compiled code into folders and files.
   
  package is collection of classes and sub packages.

Every java class must begin with package.

package packagename

if there is no package statement, then it uses default package, but it is not recommended.


How to introduce package?

package com.ibm.core

as soon as if you introduce package, java compiler creates folder in the filesystem

>javaapps\src\main\java\com\ibm\core

Types of packages:

1.java built in packages
  java language offers lot of packages which provides api to write java application
java language package starts with
 java.lang
 java.util
 java.net
 javax.xml
Note: java and javax cant be used for our own packages -  Reserved packages

2.custom packages
  Packages created for project specific.

custom packages starts with
com.
org.
Why it starts with com and org?
 =>It is standard way of defining packages. - Coding standards

com - means company
org - organization

any commerical projects starts with "com", where as any open source projects starts "org"

com                 .ibm      .core
 |                     |            |
commerical project  company Name  Project module

com.ibm.hr.    admin;
             |       |
         main module submodule

org.apache.tomcat.server


3.Third party packages
   
 Packages distributed by thrid parties, so that we can use those packages in our applications

frameworks and libs are examples of third party

 spring framework - org.spring
 junit-- org.junit
 mockito -org.mockito
etc...  


Language fundamentals:

1.data types,variables and literals

Data types:

 Java is strongly typed/static typed programming language.
 The type of variable is decided during compile time.

Data types classification:

1.primitive data types
2.reference data types/Object types

1.primitive data types

numbers
 byte,short,int,long -  whole number
Each data type has its own size.

byte:
 The byte data type is an 8-bit signed two's complement integer. It has a minimum value of -128 and a maximum value of 127 (inclusive) 

short: The short data type is a 16-bit signed two's complement integer. It has a minimum value of -32,768 and a maximum value of 32,767 (inclusive)

int: By default, the int data type is a 32-bit signed two's complement integer, which has a minimum value of -231 and a maximum value of 231-1.

long: The long data type is a 64-bit two's complement integer. The signed long has a minimum value of -263 and a maximum value of 263-1

float,double -  precision values

float: The float data type is a single-precision 32-bit IEEE 754 floating point.
double: The double data type is a double-precision 64-bit IEEE 754 floating point

chars 
 char 
The char data type is a single 16-bit Unicode character.

boolean
  The boolean data type has only two possible values: true and false. This data type represents one bit of information, but its "size" isn't something that's precisely defined.


2.Rerference types
  Size of reference types cant be fixed, collection of other types, which is calculated dynamically.

Object types
String - collection of character

package com.ibm;

public class PrimitiveDataType {
    public static void main(String[] args) {
        //numbers
        byte b = 10;
        short s = 10;
        int a = 10; //type variable=value
        long lng = 100;
        //precision values
        float price = 10.5f;
        double stock = 90.89;
        //char
        char gender = 'M';
        //boolean
        boolean isValid = true;

        System.out.println("Byte b" + b);
        System.out.println("Short s" + s);
        System.out.println("Int a" + a);
        System.out.println("Long lng" + lng);
        System.out.println("Float price" + price);
        System.out.println("Double Stock " + stock);

        System.out.println("Char Gender " + gender);
        System.out.println("Boolean isValid  " + isValid);


    }
}
..
Variables:
  Place holder which holds/refers the literals
variables can store prmiitive values or reference values(objects).

Variables are classified into various category:

1.local variables and args variables
  Variables are declared with any type(primitive/reference), with in method
2.instance variables
   variables are declared inside class
   instance variables can be any type (primitive/reference)
3.static variables 
    Variables are declared inside class with static keyword
   instance variables can be any type (primitive/reference
......................................................................................

Reference Types: string
package com.ibm;

public class ReferenceTypeStrings {
    public static void main(String[] args) {
        //Strings
        String firstName = "Subramanian";
        System.out.println(firstName);
    }
}
................................................................................
				 Operators
..............................................................................................

Most of the Operators are dervied from c / c++ :
.................................................

The Arithmetic Operators
+	Additive operator (also used for String concatenation)
-	Subtraction operator
*	Multiplication operator
/	Division operator
%	Remainder operator


........
The Unary Operators
   single operand.
 ++
The binary operators
   two operand
  a + b

+	Unary plus operator; indicates positive value (numbers are positive without this, however)
-	Unary minus operator; negates an expression
++	Increment operator; increments a value by 1
--	Decrement operator; decrements a value by 1
!	Logical complement operator; inverts the value of a boolean

package com.ibm;

public class UnaryOperators {
    public static void main(String[] args) {
        //unary operators
        int result = +1;
        // result is now 1
        System.out.println(result);

        result--;
        // result is now 0
        System.out.println(result);

        result++;
        // result is now 1
        System.out.println(result);

        result = -result;
        // result is now -1
        System.out.println(result);

        boolean success = false;
        // false
        System.out.println(success);
        // true
        System.out.println(!success);
    }
}
package com.ibm;

public class RelationalOperators {
    public static void main(String[] args) {
        int value1 = 1;
        int value2 = 2;
        if(value1package com.ibm;

public class ConditionalOperators {
    public static void main(String[] args) {
        int value1 = 1;
        int value2 = 2;
        if ((value1 == 1) && (value2 == 2))
            System.out.println("value1 is 1 AND value2 is 2");
        if ((value1 == 1) || (value2 == 1))
            System.out.println("value1 is 1 OR value2 is 1");
        //tenary opertor
        boolean someCondition = true;
        String result = someCondition ? "Hello" : "How are you?";

        System.out.println(result);

    }
}
 == value2)
            System.out.println("value1 == value2");
        if(value1 != value2)
            System.out.println("value1 != value2");
        if(value1 > value2)
            System.out.println("value1 > value2");
        if(value1 < value2)
            System.out.println("value1 < value2");
        if(value1 <= value2)
            System.out.println("value1 <= value2");
    }
}
.....................................................................................
.............................................................................................
				 Other operators

1.new Operator -  memory allocation operator
2.instanceof operator - type verification operator
.....................................................................................
Expressions, Statements, and Blocks,Control Statements:
.......................................................

Expression:
 An expression is a construct made up of variables, operators, and method invocations, which are constructed according to the syntax of the language, that evaluates to a single value

eg:
   int result = 10 *10(expression)
   int result  = calculate();

Statements:
 Statements are roughly equivalent to sentences in natural languages. A statement forms a complete unit of execution. 

1.Assignment expressions
2.Any use of ++ or --
3.Method invocations
4.Object creation expressions

// assignment statement
aValue = 8933.234;
// increment statement
aValue++;
// method invocation statement
System.out.println("Hello World!");
// object creation statement
Bicycle myBike = new Bicycle();

Blocks:
A block is a group of zero or more statements between balanced braces and can be used anywhere a single statement is allowed.

if(condition) {
  //block
}
//instance block

class A {
   
   {}
  
}
//static block
class A {
   static {}
  
}
.....................................................................................
Decision Making:

The if-then and if-then-else ,if--elseif---else Statements

The if-then Statement without else statement:


package com.ibm;

public class DecisionMaking {
    public static void main(String[] args) {
        boolean isMoving = true;
//        if (isMoving) {
//            System.out.println("Moving...");
//        }
        if (isMoving) System.out.println("Moving...");

        //if...else
        isMoving = false;
        if (isMoving) {
            System.out.println("Moving...");
        } else {
            System.err.println("The bicycle has already stopped!");
        }
        int testscore = 76;
        char grade;

        if (testscore >= 90) {
            grade = 'A';
        } else if (testscore >= 80) {
            grade = 'B';
        } else if (testscore >= 70) {
            grade = 'C';
        } else if (testscore >= 60) {
            grade = 'D';
        } else {
            grade = 'F';
        }
        System.out.println("Grade = " + grade);

    }
}
Switch ...case:
  Unlike if-then and if-then-else statements, the switch statement can have a number of possible execution paths. 
A switch works with the byte, short, char, and int primitive data types,even enums also
package com.ibm;

public class SwitchCase {
    public static void main(String[] args) {
        //
        int month = 8;
        String monthString;
        switch (month) {
            case 1:  monthString = "January";
                break;
            case 2:  monthString = "February";
                break;
            case 3:  monthString = "March";
                break;
            case 4:  monthString = "April";
                break;
            case 5:  monthString = "May";
                break;
            case 6:  monthString = "June";
                break;
            case 7:  monthString = "July";
                break;
            case 8:  monthString = "August";
                break;
            case 9:  monthString = "September";
                break;
            case 10: monthString = "October";
                break;
            case 11: monthString = "November";
                break;
            case 12: monthString = "December";
                break;
            default: monthString = "Invalid month";
                break;
        }
        System.out.println(monthString);
    }
}
.....................................................................................
				Loops:
...................................................................................
1.for 
  regular for.
  for..in loop
2.while
3.do..while

package com.ibm;

public class Loops {
    public static void main(String[] args) {
        for (int i = 1; i < 11; i++) {
            System.out.println("Count is: " + i);
        }

        int count = 1;
        while (count < 11) {
            System.out.println("Count is: " + count);
            count++;
        }
        //do...while
        int counter = 1;
        do {
            System.out.println("Count is: " + counter);
            counter++;
        } while (counter < 11);
    }
}
.....................................................................................
			     Object oriented Programming and Implementation
.....................................................................................
What is Object orientation?
  It is way of building applications.
  It is style of writing code.

Every pl follows different styles of writing code.

Styles:

1.Object oriented 
2.Functional Oriented
3.Event driven
4.Produral style
etc.....

What is Object orientation?
  It is way of building applications.
  It is style of writing code.
  It was introduced in 1960, became popular in 1970 ,C++.
  The language which follows the object orientation called "Object oriented programming   language"
Object oriented Programming langugages

1.C++
2.Java
3.C#
etc....
What is Object?
   "Every thing in this universe Object but which should be relvant to the Problem Domain/Space".

Eg:
   I am doctor, according to the doctor brian cell is object, but as a normal person 
 we dont understand about brain cell, we have not seen that.
 
As object oriented developer, we represent objects in the software domain as it is.

Object contains three things

1.state - information associated with object
2.behaviour -  methods which change the information
3.identity - to identify the object uniquly

..............................................................................................
			Objects and software systems

Software intention is to store information(data),process them,produce them.

Software design is all about how we capture the information/data, how to represent them.

Programming lanugages capture data, organize them, process them.

Programming language follows object models , which captures the data as it is in the real world.

When we capture and represent the data, we need classification. "class" -  class is core concept which capture data,how to process them.
.....................................................................................

Object oriented Concepts/principles:
....................................

1.Abstraction
2.Encapsulation
3.Hierarchy
    inheritance
    has-a -composition
4.Typing
   polymorphism
5.Modularity
6.Concurrency
7.Persistency

The language which implements these 7 principles called object oriented programming langugage.

Java has implemented all these principles.
...................................................................................

............................................................................................
				 Object Modeling Process
............................................................................................

Object oriented Anys and design

Steps :

1.Identify objects in the realtime/problem Domain. 
 eg:Banking
          Customer,Account,Loan,Employee.....


2.Appling Abstraction
   Abstraction is nothing but take necessary details from the problem domain,give up unncessary details.
 eg:
 if you go to hospital, you are now patient, now hostipal need collect only health related information not your educational details,not your personal information.

How to apply abstraction in code(java)?
 class

java syntax;

 public | package class ObjectName {
    //data - via variables with types
    //behaviour - how to change the data
    //identity  - special variable to identitfy the object
 }

What is object?

 There are two views

1.In the Problem domain
     Customer,Account,Employee
2.In the Program domain
     Object is other wise called as "instance".
   Object represent memory.
   Object means collection of variabl's memory.

  Type(className) variableName(pointer to memory address-reference)= new ClassName(); //instance /object creation
.....................................................................................
			class vs object


class is blue print which captures realtime object information(state +behaviour)
class is compile time container which caputures data.

Object:
  An instance of class
  Runtime of Representation of class

Patient.java

class Patient{}


Object creation
	Reference variable
	  |
Patient patient=new Patient()
 |			
Reference Data type

new is keyword to represent memory allocation
Patient() - constructor call


state : variables - instance variables 
variables can be of any type.


package com.ibm.oo;

public class Employee {
    //state + behaviour
    //state
    int id =1;
    String name="Subramanian";
    String city="Coimbatore";
    double salary=1000.89;
    boolean status=true;
}
package com.ibm.oo;

public class ObjectCreationMain {
    public static void main(String[] args) {
        //Create Object
        //employee is variable which type is Employee so this variable called reference variable
        //Employee is type which is Reference type
        //new is memory allocation operator
        //Employee() is constructor call , which initiates to allocate memory
        Employee employee = new Employee();
        System.out.println(employee.id);
        System.out.println(employee.name);
        System.out.println(employee.city);
        System.out.println(employee.salary);
        System.out.println(employee.status);
    }
}
...................................................................................
				Behahaviours
...................................................................................

.............................................................................................
				 Object Behaviour
..............................................................................................

What is method?

method is nothing but unit of computation.
Which performes computation.
Which mutates(change) the state(updating the variable value).

syntax:

 AccessModifer | nonAccessModifer ReturnType methodName(arg){
  //method body
  //return statement
}

package com.ibm.oo;

public class Car {
    //state
    int speed = 0;
    int gear = 0;

    //role of methods are to change the state variable
    void start() {
        //mutation changing
        speed = 5;
    }
    void changeGear(int gear) {
        this.gear = gear;
        switch (this.gear) {
            case 1:
                System.out.println("Pressing escalator ");
                speed = 10;
                break;
            case 2:
                System.out.println("Pressing escalator ");
                speed = 20;
                break;
            case 3:
                System.out.println("Pressing escalator ");
                speed = 30;
                break;
            case 4:
                System.out.println("Pressing escalator ");
                speed = 40;
                break;
            case 5:
                System.out.println("Pressing escalator ");
                speed = 60;
                break;
            default:
                System.out.println("Reverse ");
                speed = 10;
                break;

        }
    }
}
package com.ibm.oo;

public class BehaviourMain {
    public static void main(String[] args) {
        Car car = new Car();
        System.out.println("Inital Speed " + car.speed);
        //method call
        car.start();
        System.out.println("After Engine Start Speed is " + car.speed);
        //
        car.changeGear(1);
        System.out.println("After Changing Gear, Speed is  " + car.speed);
        car.changeGear(2);
        System.out.println("After Changing Gear, Speed is  " + car.speed);

    }
}
..............................................................................................
				Types of Methods
.............................................................................................

Based on How methods are accessed:

1.instance methods
2.static methods/class methods


1.instance methods:
   
  The method declared inside class, instance methods
  instance methods can be accessed only through "reference variable" with having objects.

2.static methods
 
   The method declared inside class with static keyword/modifier
  Static methods are accessed with help of ClassName.
............................................................................................
				static keyword

static keyword can be used with variable declaration and also method declarations.

if variable declared with static , called as "class variables/static variables"
if method is declared with static, called as "class methods/static methods"
.....................................................................................

state initalization:
....................

1.hardcoded
2.after object creation
3.duration object


1.hardcoded
  state intialized within class
package com.ibm.oo;

public class Car {
    //state
    int speed = 0;
    int gear = 0;    
}

2.after object creation
   Customer customer = new Customer();
        System.out.println(customer.id +" " + customer.name);
        //initialize the state after object creation
        customer.id =100;
        customer.name="Subramanian";
        System.out.println(customer.id +" " + customer.name);

3.during object creation
   Using special method called "constructors"

constructors are special methods used to initalize the state during object creation.


package com.ibm.oo;

public class Customer {

    int id = 0;
    String name = "";
    //constructors
    //constructor Name must be name of the class
    Customer(){

    }
    //arg constructors
    Customer(int id,String name){
        this.id = id;
        this.name = name;
    }

}
package com.ibm.oo;

public class CustomerMain {
    public static void main(String[] args) {
        //Customer - calling constructor without arg
        Customer customer = new Customer();
        System.out.println(customer.id +" " + customer.name);
        //initialize the state after object creation
        customer.id =100;
        customer.name="Subramanian";
        System.out.println(customer.id +" " + customer.name);

        //creating instance with new constructor
        Customer customer1 = new Customer(13,"Ram");
        System.out.println(customer1.id +" " + customer1.name);



    }
}
.....................................................................................
			Coding standards
....................................................................................

File Name:
 must be meaning full to the problem  - employee,customer
  Employee.java
class Name:
 must be meaning full to the problem
 must be noun
 must start with capital letter
 class Employee{}
 in a single file we can have multiple classes without public modifier,
 one class is recommended
variable Names
  instance variables : within class , belongs objects
  camelCased
  int id;
  String firstName;

method names;
  
two types of methods
1.biz method
   which change state according biz logic
eg:
void start() {
        //mutation changing
        speed = 5;
    }
    void changeGear(int gear) {
        this.gear = gear;
        switch (this.gear) {
            case 1:
                System.out.println("Pressing escalator ");
                speed = 10;
                break;
            case 2:
                System.out.println("Pressing escalator ");
                speed = 20;
                break;
            case 3:
                System.out.println("Pressing escalator ");
                speed = 30;
                break;
            case 4:
                System.out.println("Pressing escalator ");
                speed = 40;
                break;
            case 5:
                System.out.println("Pressing escalator ");
                speed = 60;
                break;
            default:
                System.out.println("Reverse ");
                speed = 10;
                break;

        }
    }
2.state accessor and mutator methods - setters and getters.
  
coding standard for state initalization:

only we can initalize the state in two ways.

how to declare state?

 private datatype variable; 

package com.ibm.oo;

public class Product {
    //state declaration according to coding standard
    private int id;
    private String productName;
    private double qty;
    private double price;

}

how to access the instance variables

As per coding standard, instance variable should not be accessed directly.

product.id invalid

via setters(initalization) and getters(reading)

package com.ibm.oo;

public class Product {
    //state declaration according to coding standard
    private int id;

    private String productName;
    private double qty;
    private double price;

    public Product() {
    }

    public Product(int id, String productName, double qty, double price) {
        this.id = id;
        this.productName = productName;
        this.qty = qty;
        this.price = price;
    }

    public double getQty() {
        return qty;
    }

    public void setQty(double qty) {
        this.qty = qty;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }




    //setter : write - init
    public void setId(int id) {
        this.id = id;
    }

    public void setProductName(String productName) {
        this.productName = productName;
    }

    //getter : read
    public int getId() {
        return id;
    }

    public String getProductName() {
        return productName;
    }
}

package com.ibm.oo;

public class ProductMain {
    public static void main(String[] args) {
        Product product = new Product();
        product.setId(1);
        product.setProductName("Mobile");
        product.setQty(13);
        product.setPrice(23.76);
        System.out.println(product.getId());
        System.out.println(product.getProductName());
        System.out.println(product.getQty());
        System.out.println(product.getPrice());

        product = new Product(23, "Watch", 10, 298.87);
        System.out.println(product.getId());
        System.out.println(product.getProductName());
        System.out.println(product.getQty());
        System.out.println(product.getPrice());
    }
}
.....................................................................................
			 Encapsulation
....................................................................................

How to prevent / share code with in application?

code means - class ,variables,constructors,methods

in java , there are keywords private,public,protected,default

private keyword can be used
with 
1.instance variables,mehthods,constructors
private means outside class not able access.


package com.ibm.oo.enc;

public class Employee {
    //instance variables
    private int id;

    //private methods
    private String generatePassword(){
        return "Abc";
    }
    public String auth(){
        return generatePassword();
    }
}
package com.ibm.oo.enc;

public class EmployeeMain {
    public static void main(String[] args) {
        Employee employee=new Employee();
        //employee.id;
//        System.out.println(employee.generatePassword());
        System.out.println(employee.auth());
//        Factory factory = new Factory();

    }
}
.................................................................................
			private constructors


=> to hide object creations using new Operator
  i dont want to do like below
    Factory factor =new Factory();

=>There is solution.

package com.ibm.oo.enc;

public class Factory {
    private Factory(){

    }
    public String getInfo(){
        return "Hello";
    }
    //to create instance , use static method:
    //static methods are accessiable without object, using class Name
    public static Factory getInstance(){
        return new Factory();
    }
}
package com.ibm.oo.enc;

public class EmployeeMain {
    public static void main(String[] args) {
        Employee employee = new Employee();
        //employee.id;
//        System.out.println(employee.generatePassword());
        System.out.println(employee.auth());
//        Factory factory = new Factory();
        //
        //static methods are accessed with help of Class name
        Factory factory = Factory.getInstance();
        System.out.println(factory.getInfo());

    }
}
.....................................................................................
				public 

class,variables,methods,constructors can be public 

public means any where in the application.
public class Product {
}
package com.ibm.oo.enc;

public class Product {
    //public int id; it is valid but not recommeneded as per java standards

    public Product() {
    }

    public void calculate(){
        System.out.println("public methods");
    }
}
.....................................................................................
				default

package spefic.

java packages:
.............
1.built in package
2.custom packages
3.thrid packages

there keywords

package nameof the package

package com.ibm
package com.ibm.oo.enc

import com.ibm.className
import com.ibm.*; - to import all classes from this package.

package com.ibm.services;

public class ProductService {
    public String getInfo() {
        return "Product";
    }
}

package com.ibm.app;

import com.ibm.services.ProductService;

//import com.ibm.services.*;


public class ProductServiceMain {
    public static void main(String[] args) {
        ProductService productService = new ProductService();
    }
}

default , with out any keyword

class ProductService{} - package scope

class ProductService {
    public String getInfo() {
        return "Product";
    }
}


This would be error.

package com.ibm.app;

import com.ibm.services.ProductService;

//import com.ibm.services.*;


public class ProductServiceMain {
    public static void main(String[] args) {
        ProductService productService = new ProductService();
    }
}
.....................................................................................
			   protected
.....................................................................................
Hiearchy: code sharing , How to avoid duplicate code?

has-a
  dependancy injection.

package com.ibm.hasa;

public class Address {
    //address
    private String city;
    private String state;

    public Address() {
    }

    public Address(String city, String state) {
        this.city = city;
        this.state = state;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
}
package com.ibm.hasa;

public class Employee {
    private  int id;
    private String name;

    public Employee() {
    }

    public Employee(int id, String name, Address address) {
        this.id = id;
        this.name = name;
        this.address = address;
    }

    //link the address
    //has-a
    private Address address;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }
}




package com.ibm.hasa;

public class ProductService {

    public String getProduct(){
        return "Product";
    }
}
package com.ibm.hasa;

public class HasAMain {
    public static void main(String[] args) {
        Address address = new Address("Coimbatore", "TN");
        Employee employee = new Employee(1, "Subramanian", address);
        System.out.println(employee.getId());
        System.out.println(employee.getName());
        System.out.println(employee.getAddress().getCity() + " " + employee.getAddress().getState());


        ProductController productController = new ProductController(new ProductService());
        System.out.println(productController.getProductService().getProduct());
    }
}
.....................................................................................
                               is-a - inheritance


1.class based 
2.interface based
3.abstract class


package com.ibm.isa;

public class Account {
    public double deposit(){
        return 0.0;
    }
}
package com.ibm.isa;

public class SavingsAccount extends Account{
    //spcific method to savings account
    public double calculate(){
        return 100;
    }
}
package com.ibm.isa;

public class InheritanceMain {
    public static void main(String[] args) {
        SavingsAccount savingsAccount =new SavingsAccount();
        System.out.println(savingsAccount.calculate());
        System.out.println(savingsAccount.deposit());
    }
}
.....................................................................................
			Typing - Polymorphism........
....................................................................................

There are two types of polymorphism
1.compile time polymorphism
   -overloading

overloading types
1.method overloading
2.constructor overloading

compile time polymorphism is implemented inside class only.
 having same method/constructor , doing different functinality.

package com.ibm.poly.overloading;

package com.ibm.poly.overloading;

public class Calculator {

    private int x;
    private int y;
    private int z;

    //constructor overloading : having many constructors with different set of args

    public Calculator() {
    }

    public Calculator(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public Calculator(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    //req : sum
    //without overloading
    public int addTwoNum(int a, int b) {
        return a + b;
    }

    public int addThreeNum(int a, int b, int c) {
        return a + b + c;
    }

    //with overloaing
    public int sum(int a, int b) {
        return a + b;
    }

    public int sum(int a, int b, int c) {
        return a + b + c;
    }
}
package com.ibm.poly.overloading;

public class OverloadingMain {
    public static void main(String[] args) {
        Calculator calculator = new Calculator();
        System.out.println(calculator.addTwoNum(13, 45));
        System.out.println(calculator.addThreeNum(12, 3, 4));
        System.out.println(calculator.sum(11, 100));
        System.out.println(calculator.sum(34, 90, 90));
        calculator = new Calculator(23, 90);
        calculator = new Calculator(78, 9, 0);
    }
}


2.run time polymorphism
  -overriding
    we can override methods across in the inheritance only.
Parent class defines one method, we have to define the same method with same arg,
but return type may be different,access modifer differ.

package com.ibm.poly.overloading;

public class Account {
    public double deposit(double amount) {
        System.out.println("Account");
        return amount * 0;
    }
}


package com.ibm.poly.overloading;

public class SavingsAccount extends  Account{
    //overriding
    public double deposit(double amount) {
        System.out.println("Savings Account");
        return amount * 10;
    }
}

package com.ibm.poly.overloading;


public class Overriding {
    public static void main(String[] args) {
        SavingsAccount savingsAccount = new SavingsAccount();
        System.out.println(savingsAccount.deposit(1000.89));
    }
}

...................................................................................
			How inheritance is happing

Source code

Account.java
package com.ibm.poly.overloading;

public class Account {
    public double deposit(double amount) {
        System.out.println("Account");
        return amount * 0;
    }
}
package com.ibm.poly.overloading;

SavingsAccount.java
public class SavingsAccount extends  Account{

}
public class Overriding {
    public static void main(String[] args) {
        SavingsAccount savingsAccount = new SavingsAccount();
        System.out.println(savingsAccount.deposit(1000.89));
    }
}

Output :
Account
0.0

After compilation;

Account.class

package com.ibm.poly.overloading;

public class Account extends Object {
    public double deposit(double amount) {
        System.out.println("Account");
        return amount * 0;
    }
}
package com.ibm.poly.overloading;

SavingsAccount.class


public class SavingsAccount extends  Account{
    public double deposit(double amount) {
    	  return super.deposit(amount)    
    }
}
public class Overriding {
    public static void main(String[] args) {
        SavingsAccount savingsAccount = new SavingsAccount();
        System.out.println(savingsAccount.deposit(1000.89));
    }
}
....................................................................................
			 Program to Super Type
....................................................................................


Types in java is classified into two

primitives
 int,float
Reference types 
 Object types

Employee emp;

The reference variable can have the following type

The concrete type
  SavingsAccount savingsAccount = new SavingsAccount();
     |             |                      |
  Type             Reference Variable   constructor

The type of variable can be changed from concrete to super type

 Account savingsAccount = new SavingsAccount();
 
The type of reference variable can be Super class Typle


package com.ibm.poly.supertype;

public class Animal {
    public String eat(){
        return "Animal eats";
    }
}
package com.ibm.poly.supertype;

public class Tiger extends  Animal{
  //
    public String hunt(){
        return "Hunt";
    }
}
package com.ibm.poly.supertype;

public class SupertypeMain {
    public static void main(String[] args) {
        Tiger tiger = new Tiger();
        System.out.println(tiger.eat());
        System.out.println(tiger.hunt());

        //program to super type
        Animal tiger1= new Tiger();
        System.out.println(tiger1.eat());
        //System.out.println(tiger1.hunt());
    }
}
.....................................................................................

Java applies some rules:

 During compile time the variable(tiger) binding with methods(eat) always looks the type(Tiger)
 Tiger tiger = new Tiger();
 tiger.eat()
 
  Animal tiger1= new Tiger();
        System.out.println(tiger1.eat());
        //System.out.println(tiger1.hunt());

 here hunt does not belong to Animal type, so we cant compile

Solution:
  1.We have do type conversion/casting - down casting

package com.ibm.poly.supertype;

public class SupertypeMain {
    public static void main(String[] args) {
        Tiger tiger = new Tiger();
        System.out.println(tiger.eat());
        System.out.println(tiger.hunt());

        //program to super type
        Animal animal = new Tiger();
        System.out.println(animal.eat());
        //System.out.println(animal.hunt());
        //casting - down casting
        Tiger tmpTiger = (Tiger) animal;
        System.out.println(tmpTiger.hunt());
    }
}
.....................................................................................
				interfaces
....................................................................................

inheritance is used to reuse code across the family of classes.

classes are used to share code in the same family.

interfaces are similar to classes but it can be used to share behaviour across the family of classes.

interface is similar to class having 

1.abstract methods- methods do have implmentation
2.default concrete methods

package com.ibm.isa.interfaces;

public interface Flyable {
    //abstract method
    String fly();
}
package com.ibm.isa.interfaces;

public class Bird implements Flyable {
    @Override
    public String fly() {
        return "Bird Flies";
    }
}
package com.ibm.isa.interfaces;

public class Flight implements Flyable {
    @Override
    public String fly() {
        return "Flight flies";
    }
}
package com.ibm.isa.interfaces;

public class InterfaceMain {
    public static void main(String[] args) {
        Flyable flyable = new Flight();
        System.out.println(flyable.fly());
        //
        flyable = new Bird();
        System.out.println(flyable.fly());
    }
}
....................................................................................
			 Abstract classes
...................................................................................

Abstract class = interface + concret class


package com.ibm.isa.abscls;

abstract public class Animal {
    //abstract methods
    abstract void eat();

    //non abstract methods
    void saveAnimals() {
        System.out.println("Save Animals from the hunting");
    }
}
package com.ibm.isa.abscls;

abstract public class Animal {
    //abstract methods
    abstract void eat();

    //non abstract methods
    void saveAnimals() {
        System.out.println("Save Animals from the hunting");
    }
}
package com.ibm.isa.abscls;

public class Dog extends Animal{
    @Override
    void eat() {
        System.out.println("Dog eats");
    }
}
package com.ibm.isa.abscls;

public class Cat extends Animal{
    @Override
    void eat() {
        System.out.println("Cat eats");
    }
}
package com.ibm.isa.abscls;

public class AbstractMain {
    public static void main(String[] args) {
        Animal animal =new Cat();
        animal.saveAnimals();
        animal.eat();
        Cat tmpCat = (Cat)animal;
        tmpCat.memow();
        animal =new Dog();
        animal.saveAnimals();
        animal.eat();
    }
}
.....................................................................................
				java.lang.Object
.....................................................................................

Employee.java
class Employee {}

After compilation

Employee.class
class Employee  extends java.lang.Object
{

}

class Account{}

class SavingsAccount extends Account{}


class Account extends java.lang.Object {}

class SavingsAccount extends Account{}


interface Account extends java.lang.Object {}

class SavingsAccount implements Account {


}
			 java.lang.Object

Methods:

1.toString()
   It returns string representation of Object.
if you dont override this method in any class java.lang.Object toString is method.

by default toString method returns value like below

com.sapient.oo.objectclass.Greeting@1d251891


Overriding toString method and get meaningfull output
package com.sapient.oo.objectclass;

public class Greeting {

    private String message;
    private String name;

    public Greeting(){

    }

    public Greeting(String message, String name) {
        this.message = message;
        this.name = name;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    //Override to String method

    @Override
    public String toString() {
        return "Greeting{" +
                "message='" + message + '\'' +
                ", name='" + name + '\'' +
                '}';
    }
}
public class ObjectMain {
    public static void main(String[] args) {
        Greeting greeting = new Greeting("Hello","Subramanian");
        //System.out.println(greeting.getMessage() + " " +greeting.getName());
        //toString
        System.out.println(greeting.toString());
        System.out.println(greeting); //here toString is called automatically
    }
}
..............................................................................................
				hashcode()


hashcode method returns an integer which represents hash value of the java object.
System.out.println(greeting.hashCode());

Can i override hashcode?

Yes
package com.sapient.oo.objectclass;

import java.util.Objects;

public class Greeting {

    private String message;
    private String name;

    public Greeting(){

    }

    public Greeting(String message, String name) {
        this.message = message;
        this.name = name;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    //Override to String method

    @Override
    public String toString() {
        return "Greeting{" +
                "message='" + message + '\'' +
                ", name='" + name + '\'' +
                '}';
    }
    //override hashcode
//    @Override
//    public int hashCode() {
//        return 100;
//    }
    @Override
    public int hashCode() {
        return Objects.hash(message,name);
    }
}
      package com.sapient.oo.objectclass;

public class ObjectMain {
    public static void main(String[] args) {
        Greeting greeting = new Greeting("Hello","Subramanian");
        System.out.println(greeting.hashCode());
    }
}
..............................................................................................
				equals Method
..............................................................................................

To test equality of objects.

In order to test equality we have == operator and also we have equals Method.

== Operator:
...........

With Primitive Values to test two different variables having same value or not.
        int a = 10;
        int b = 10;
        if (a == b) {
            System.out.println("Equal");
        } else {
            System.out.println("Not equal");
        }

With Reference types and equal operator

        Greeting greeting1 = new Greeting("Hello", "Subramanian");
        Greeting greeting2 = new Greeting("Hai", "Ram");

        if (greeting1 == greeting2) {
            System.out.println("Greetings are equal");
        } else {
            System.out.println("Greetings are not equal");
        }

Here we are comparing not objects but object locations.

 "Whether two reference variables points the same object(one location) or not"

Here no, so it will give "Greetings are not equal".
 //Equal condition with single object
        Greeting greeting3 = new Greeting();
        Greeting greeting4 = greeting3;
        if (greeting3 == greeting4) {
            System.out.println("Greetings are equal");
        } else {
            System.out.println("Greetings are not equal");
        }
.............................................................................................
				equals method
.............................................................................................

=>This method is used to compare objects only not its memory location.
   
  If i create two objects having content are same
  eg : Two Employee objects having same employeeid.



package com.sapient.oo.objectclass;

import java.util.Objects;

public class Greeting {

    private int id;
    private String message;
    private String name;

    public Greeting(){

    }

    public Greeting(int id,String message, String name) {
        this.id =id;
        this.message = message;
        this.name = name;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    //Override to String method

    @Override
    public String toString() {
        return "Greeting{" +
                "message='" + message + '\'' +
                ", name='" + name + '\'' +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Greeting)) return false;
        Greeting greeting = (Greeting) o;
        return id == greeting.id;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}

package com.sapient.oo.objectclass;
public class EqualsMethodMain {
    public static void main(String[] args) {
        Greeting greeting1 = new Greeting(1,"Hello","Subramanian");
        Greeting greeting2 = new Greeting(6,"Hello","Subramanian");
        System.out.println("Greeting 1 Hashcode " + greeting1.hashCode());
        System.out.println("Greeting 2 Hashcode " + greeting2.hashCode());

        //by default equals method test object reference equality using == operator
        System.out.println(greeting1.equals(greeting2) ? "Objects are equal" : "Objects are not equal");

    }
}
.....................................................................................
			 Exception Handling
.....................................................................................

Types of Exception:
1.unChecked
   you dont need to write any special code to handle the errors

eg:
 NullPointerException
 NumberformateException

2.Checked
   We have to write special code to handle the errors other wise it will not compile

.............................................................................................
				   Exception handling
.............................................................................................
In software systems errors are common, which is unavoidable.

Types of errors:

1.Program errors
   ->compile time errors
      Errors are identified during development time
    compile time errors are not danger,because can be fixed

   ->Runtime errors 
      Errors are identified during runtime of application.
      Errors are danager which stops the application to run.
      This is unavoiable
      This has to be handled properly    
        Handling runtime errors are called "exception handling"

2.System errors
    Due to system mal function like , sudden machine restarts,disk failure,io devices failures,memory overflow.
    We cant fix / handle this via software

How to handle Exception(Application Runtime errors)?

java provides a mechanism to handle errors sommothly.

if you dont write error handling code, java will do automatically.
.............................................................................................
				Handling exceptions


java provides keywords to handle exception

1.try...catch..finally
2.throw 
3.throws 

Exception is Object oriented, java provides a base class to abstract exception.

				java.lang.Throwable

The Throwable class is the superclass of all errors and exceptions in the Java language
Only objects that are instances of this class (or one of its subclasses) are thrown by the Java Virtual Machine or can be thrown by the Java throw statement


				java.lang.Throwable
					 |
		---------------------------------------------------------
                |							|
             java.lang.Error                                     java.lang.Exception




Error:
   An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch.
Most such errors are abnormal conditions. The ThreadDeath error, though a "normal" condition, is also a subclass of Error because most applications should not try to catch it.

Exception:
  The class Exception and its subclasses are a form of Throwable that indicates conditions that a reasonable application might want to catch.

............................................................................................
				 Types of Exception
............................................................................................

1.UnChecked Exception

    Exceptions need not be handled by write special code(try...catch).
    what if exceptions occured, JVM will handle auotmatically.

Eg;
   NullPointerException
       Exception(error) , is thrown by the jvm incase if you access object properties , if object does not exit.

  static void checkNullException() {
        String str = null;
        System.out.println(str.length());
    }
  NumberFormatException
     Incase string to number conversion, if it fails
    static  void checkNumberFormate(){
        String str = "$10";
        int a = Integer.parseInt(str);
        System.out.println(a);
    }
etc...

How to identify the unchecked Exception?
			
 if any exception inherits "java.lang.RuntimeException" or any Exception subclass of RuntimeException are called "UnChecked Exception"


How to handle Unchecked Exception?
  Handling means reporting errors.

try....catch block
static void handleException() {
        try {
            //your application
            String str = "$10";
            int a = Integer.parseInt(str);
            System.out.println(a);
        } catch (NumberFormatException es) {
            //reporting block
            System.out.println(es.getMessage());
        }

    }

2.Checked Exception
    Exceptions need to be handled by writing code using try...catch or throws.
    The code which throws CheckedException, without handling using try...catch or throws , we cant compile the code.

CheckedException is used in many java apis

1.java.io apis
2.java.sql apis
3.java.net apis
etc.....
.................................................................................
.............................................................................................
				   Exception handling
.............................................................................................
In software systems errors are common, which is unavoidable.

Types of errors:

1.Program errors
   ->compile time errors
      Errors are identified during development time
    compile time errors are not danger,because can be fixed

   ->Runtime errors 
      Errors are identified during runtime of application.
      Errors are danager which stops the application to run.
      This is unavoiable
      This has to be handled properly    
        Handling runtime errors are called "exception handling"

2.System errors
    Due to system mal function like , sudden machine restarts,disk failure,io devices failures,memory overflow.
    We cant fix / handle this via software

How to handle Exception(Application Runtime errors)?

java provides a mechanism to handle errors sommothly.

if you dont write error handling code, java will do automatically.
.............................................................................................
				Handling exceptions


java provides keywords to handle exception

1.try...catch..finally
2.throw 
3.throws 

Exception is Object oriented, java provides a base class to abstract exception.

				java.lang.Throwable

The Throwable class is the superclass of all errors and exceptions in the Java language
Only objects that are instances of this class (or one of its subclasses) are thrown by the Java Virtual Machine or can be thrown by the Java throw statement


				java.lang.Throwable
					 |
		---------------------------------------------------------
                |							|
             java.lang.Error                                     java.lang.Exception




Error:
   An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch.
Most such errors are abnormal conditions. The ThreadDeath error, though a "normal" condition, is also a subclass of Error because most applications should not try to catch it.

Exception:
  The class Exception and its subclasses are a form of Throwable that indicates conditions that a reasonable application might want to catch.

............................................................................................
				 Types of Exception
............................................................................................

1.UnChecked Exception

    Exceptions need not be handled by write special code(try...catch).
    what if exceptions occured, JVM will handle auotmatically.

Eg;
   NullPointerException
       Exception(error) , is thrown by the jvm incase if you access object properties , if object does not exit.

  static void checkNullException() {
        String str = null;
        System.out.println(str.length());
    }
  NumberFormatException
     Incase string to number conversion, if it fails
    static  void checkNumberFormate(){
        String str = "$10";
        int a = Integer.parseInt(str);
        System.out.println(a);
    }
etc...

How to identify the unchecked Exception?
			
 if any exception inherits "java.lang.RuntimeException" or any Exception subclass of RuntimeException are called "UnChecked Exception"


How to handle Unchecked Exception?
  Handling means reporting errors.

try....catch block
static void handleException() {
        try {
            //your application
            String str = "$10";
            int a = Integer.parseInt(str);
            System.out.println(a);
        } catch (NumberFormatException es) {
            //reporting block
            System.out.println(es.getMessage());
        }

    }

2.Checked Exception
    Exceptions need to be handled by writing code using try...catch or throws.
    The code which throws CheckedException, without handling using try...catch or throws , we cant compile the code.

CheckedException is used in many java apis

1.java.io apis
2.java.sql apis
3.java.net apis
etc.....
..............................................................................................
				Custom Exception /Biz Exception
.............................................................................................

Custom Exceptions /Biz Exceptions can be created based on our application code.

Custom Exception can be checked or unchecked Exception.
............................................................................................
				UnChecked Custom Exception
.............................................................................................

Steps:

1.Write a class extends "java.lang.RuntimeException".

2.add Constructors 

public class BalanceNotFoundException extends RuntimeException {
    public BalanceNotFoundException() {
        super(); // calling super class constructor
    }
    public BalanceNotFoundException(String errorMessage) {
        super(errorMessage); // calling super class constructor
    }
}

3.write biz class , and methods ,simulate exception.

we have to create Exception Object, we have to throw it

package com.sapient.exceptions.custom.uncheck;

public class AccountService {
    private double balance = 1000.00;

    public double witdraw(double amt) {
        if (balance < amt) {
            //error : you are throwing where this method is called.
            throw new BalanceNotFoundException("Balance Not Found " + "balace=>" + balance + "amt to be withdrawn =>" + amt);
        }
        return balance - amt; //balance
    }
}

4.call biz method , handle exception 

package com.sapient.exceptions.custom.uncheck;

public class Main {
    public static void main(String[] args) {
        AccountService accountService = new AccountService();
        double response = 0.0;
        response = accountService.witdraw(100);
        System.out.println("Response is " + response);
        //without try catch code will be compiled...
//        response = accountService.witdraw(3000);
//        System.out.println("Response is " + response);
        //with try ...catch
        try {
            response = accountService.witdraw(3000);
            System.out.println("Response is " + response);
        } catch (BalanceNotFoundException es) {
            System.out.println(es.getMessage());
        }

    }
}
.............................................................................................
				Checked Custom Exception
.............................................................................................

Steps

1.Write a class extends "java.lang.Exception".


public class BalanceNotFoundException extends Exception {
    public BalanceNotFoundException() {
        super(); // calling super class constructor
    }
    public BalanceNotFoundException(String errorMessage) {
        super(errorMessage); // calling super class constructor
    }
}

2.write biz class , and methods ,simulate exception.
public class AccountService {
    private double balance = 1000.00;

    public double witdraw(double amt) {
        if (balance < amt) {
            //error : you are throwing where this method is called.
            throw new BalanceNotFoundException("Balance Not Found " + "balace=>" + balance + "amt to be withdrawn =>" + amt);
        }
        return balance - amt; //balance
    }
}

You will get compile time error:
 Unhandled exception: com.sapient.exceptions.custom.checked.BalanceNotFoundException

We have not called exception, but why we are getting this error. we need to bind CheckedException with this method.

"throws" -  keyword used to bind Checked Exception with method.

public class AccountService {
    private double balance = 1000.00;

    public double witdraw(double amt) throws BalanceNotFoundException {
        if (balance < amt) {
            //error : you are throwing where this method is called.
            throw new BalanceNotFoundException("Balance Not Found " + "balace=>" + balance + "amt to be withdrawn =>" + amt);
        }
        return balance - amt; //balance
    }
}

3. caller side
public class Main {
    public static void main(String[] args) {
        AccountService accountService = new AccountService();
        double response = 0.0;
        response = accountService.witdraw(100);
        System.out.println("Response is " + response);
    }
}
here compiler will throw error
Unhandled exception: com.sapient.exceptions.custom.checked.BalanceNotFoundException

Here checkedException forces to handle it

using try ...catch...
      try {
            response = accountService.witdraw(4000);
            System.out.println("Response is " + response);
        } catch (BalanceNotFoundException e) {
            System.out.println(e.getMessage());
        }

Sometimes , we are interested to use try...catch, how to compile the code?

yes we can , escaping handling exception using try...catch.

"using throws" keyword
package com.sapient.exceptions.custom.checked;

public class Main {
    public static void main(String[] args) throws BalanceNotFoundException {
        AccountService accountService = new AccountService();
        double response = 0.0;
        response = accountService.witdraw(4000);
        System.out.println("Response is " + response);

//        try {
//            response = accountService.witdraw(4000);
//            System.out.println("Response is " + response);
//        } catch (BalanceNotFoundException e) {
//            System.out.println(e.getMessage());
//        }
    }
}
.............................................................................................
			 finally keyword


finally is used for writing some clean up activties such as file closing operations,like so
finally is called whether exception is thrown are not.

package com.sapient.exceptions.custom.checked;

public class Main {
    public static void main(String[] args) { // throws BalanceNotFoundException {
        AccountService accountService = new AccountService();
        double response = 0.0;
        try {
            response = accountService.witdraw(1000);
            System.out.println("Response is " + response);
        } catch (BalanceNotFoundException e) {
            System.out.println(e.getMessage());
        } finally {
            System.out.println("called");
        }
    }
}
............................................................................................
				multi catch

We can have mulitple catch Statement. Each catch statement is used to identifiy specific errors.


package com.sapient.exceptions;

public class MulitCatch {

    public static void checkMultiCatch() {
        try {
            String str = "10";
            System.out.println(Integer.parseInt(str));
            String str2 = "";
            System.out.println(str2.toUpperCase());
            int a = 10;
            int res = a / 0;
            System.out.println(res);

        } catch (NumberFormatException es) {
            System.out.println("Number error");
        } catch (NullPointerException es) {
            System.out.println("Null Error");
        } catch (RuntimeException es) {
            System.out.println(es.getMessage());
        } catch (Exception es) {
            System.out.println(es.getMessage());
        } catch (Throwable es) {
            System.out.println(es.getMessage());
        }
    }

    public static void main(String[] args) {
        checkMultiCatch();
    }
}
.....................................................................................

Java supports IO operations via java.io and javax.nio package.

Java can read and write bytes/characters from the various sources

Sources:
 - Keyboard
 - File
 - Network sockets
Java reads or writes data in the two forms

1.byte 
2.char

Java uses a concept called "stream"

Stream is nothing but "flow of data" 

Types of Streams:

1.Byte Streams
  handle I/O of raw binary data.
2.Character Streams 
   handle I/O of character data, automatically handling translation to and from the local character set.
3.Buffered Streams
  optimize input and output by reducing the number of calls to the native API.
4.Scanning and Formatting 
    allows a program to read and write formatted text.
5.I/O from the Command Line 
  describes the Standard Streams and the Console object.
6.Data Streams 
   handle binary I/O of primitive data type and String values.
7.Object Streams 
   handle binary I/O of objects.


Byte Streams
   Programs use byte streams to perform input and output of 8-bit bytes. All byte stream classes are descended from InputStream and OutputStream.

  There are many byte stream classes. To demonstrate how byte streams work, we'll focus on the file I/O byte streams, FileInputStream and FileOutputStream. Other kinds of byte streams are used in much the same way; they differ mainly in the way they are constructed.

package com.ibm.io;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class ReadFile {
    public static void main(String[] args) {
        //E:\session\IBM\2022\july\BootCamp\JavaApps\src\main\resources
        String filename = "E:\\session\\ibm\\2022\\july\\bootcamp\\javaApps\\src\\main\\resources\\hello.txt";        //
        try {
            FileInputStream fileInputStream = new FileInputStream(filename);
            //read file content
            int data;
            while ((data = fileInputStream.read()) != -1) {
                //  System.out.println(data + "  " + (char) data);
                System.out.print((char) data);
            }
        } catch (FileNotFoundException e) {
            System.out.println(e.fillInStackTrace());
        } catch (IOException e) {
            System.out.println(e.fillInStackTrace());
        }
    }
}
...

package com.ibm.io;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class FileReadAndWrite {
    public static void main(String[] args) {
        try {
            String filename = "E:\\session\\ibm\\2022\\july\\bootcamp\\javaApps\\src\\main\\resources\\hello.txt";        //

            FileInputStream fileInputStream = new FileInputStream(filename);

            FileOutputStream fileOutputStream = new FileOutputStream("hello_copy.txt", true);
            System.out.println(fileOutputStream.getFD());
            int data;
            while ((data = fileInputStream.read()) != -1) {
                //System.out.print((char) data);
                fileOutputStream.write(data);
            }

        } catch (FileNotFoundException e) {
            System.out.println("file Not found" + e);
        } catch (IOException e) {
            System.out.println("IO Exception" + e.getMessage());
        }

    }
}
..................................................................................
..............................................................................................
				 Data Structures
.............................................................................................

1.Array :
 
In java array is Object.
Java arrays are fixed in size
Java arrays store only one type of data.

package com.sapient.ds.arrays;

public class ArrayDemo {
    public static void main(String[] args) {
        int[] list = {1, 2, 3, 4, 5, 6, 7};
        System.out.println("length" + list.length);
        //iterate
        for (int i = 0; i < list.length; i++) {
            System.out.println(list[i]);
        }
        //Array of employees
        Employee[] employees = {
                new Employee(1, "A"),
                new Employee(2, "B")
        };
        for (int i = 0; i < employees.length; i++) {
            System.out.println(employees[i]);
        }
    }
}
.....................................................................................
..............................................................................................
				Collections Framework

Collections framework is ready made data structure.

				  java.util.Collection

The root interface in the collection hierarchy. A collection represents a group of objects, known as its elements. Some collections allow duplicate elements and others do not. Some are ordered and others unordered

				 java.util.Collection
					 |
		          java.util.List        java.util.Set

Behind every Collection implementation is array which is dynamic.


List:

An ordered collection (also known as a sequence)
  Order could be index,hashvalue,insertion order
Lists typically allow duplicate elements


				 java.util.Collection
					 |
		          	   java.util.List 
					 |

1.ArrayList
2.LinkedList
3.Stack					


ArrayList:
ArrayList()

 Constructs an empty list with an initial capacity of ten.

ArrayList(Collection<? extends E> c)
 Constructs a list containing the elements of the specified collection, in the order they are returned by the collection's iterator.

ArrayList(int initialCapacity)
  Constructs an empty list with the specified initial capacity.

Generics:
  Type container

In the begining , the collection was designed to accept only objects with type of java.lang.Object
  
Why Generics?


import java.util.ArrayList;
import java.util.Iterator;

public class ArrayListMain {
    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        list.add(10); // list.add(new Integer(10)) Object o = new Integer
        list.add("Hello");
        //iterate
        Iterator iterator = list.iterator();
        while (iterator.hasNext()) {
            Integer ins = (Integer) iterator.next();
            System.out.println(ins.intValue() * 10);
        }
    }

100
Exception in thread "main" java.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Integer (java.lang.String and java.lang.Integer are in module java.base of loader 'bootstrap')
	at com.sapient.ds.collections.ArrayListMain.main(ArrayListMain.java:14)

ClassCastException is most the dangerous exception which could be arrived in runtime only.


How to avoid classCastException?

 We have to prevent List to accept multiple types.

List should accept only Integers.

We need to create compile time error.

Generics concept were introduced. Generics prevent multiple type to be added , can be fixed during compile time.			


package com.ibm.ds;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Stack;

public class LinkdeListDemo {
    public static void main(String[] args) {
        ArrayList<String> arrayList = new ArrayList<>();
        arrayList.add("hello");
        arrayList.add("hai");
        arrayList.add("greet");
        arrayList.add("welcome");
        for (String item : arrayList) {
            System.out.println(item);
        }
        System.out.println("..............");
        LinkedList<String> linkedList = new LinkedList<>();
        linkedList.add("hello");
        linkedList.addFirst("welcome");
        for (String item : linkedList) {
            System.out.println(item);
        }
        //stack : L
        Stack<Integer> integers = new Stack<>();
        integers.push(1);
        integers.push(3);
        integers.push(2); // l
        int vale = integers.pop(); // last value in the stack will be read
        System.out.println(vale);

    }
}

ArrayList - order is index order(0th,1th...)
LinkedList -is insertion order(how you insert)
Stack  -is last in first Order
....................................................................................
			.............................................................................................
				  Set
..............................................................................................

A collection that contains no duplicate elements,like list only.

Set Implementation:

1.HashSet  == ArrayList
2.LinkedHashSet ===LinkedList
3.TreeSet
<Type>

ArrayList<Integer> list = new ArrayList<Integer>()
ArrayList list = new ArrayList<Integer>()

  //Generics Version
        ArrayList<Integer> list = new ArrayList<Integer>();
        list.add(10); // list.add(new Integer(10)) Object o = new Integer
        //list.add("hello");
        list.add(20);
        //iterate
        Iterator iterator = list.iterator();
        while (iterator.hasNext()) {
            Integer ins = (Integer) iterator.next();
            System.out.println(ins.intValue() * 10);
        }



package com.sapient.ds.collections;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class ListProcessingMain {
    public static void processIntList() {
        List<Integer> list = new ArrayList<Integer>();
        list.add(100);
        list.add(1);
        list.add(2);
        list.add(200);
        System.out.println("Before Sorting");
        for (Integer val : list) {
            System.out.println(val);
        }
        Collections.sort(list);
        System.out.println("After Sorting");
        for (Integer val : list) {
            System.out.println(val);
        }
    }

    public static void processEmployeeList() {
        List<Employee> employeeList = new ArrayList<>();
        employeeList.add(new Employee(1, "A1", 100.89));
        employeeList.add(new Employee(3, "A3", 1070.89));
        employeeList.add(new Employee(2, "A2", 10330.89));
        employeeList.add(new Employee(5, "A5", 10670.89));
        System.out.println("Before Sorting");
        for (Employee employee : employeeList) {
            System.out.println(employee);
        }
        Collections.sort(employeeList);
        System.out.println("After Sorting");
        for (Employee employee : employeeList) {
            System.out.println(employee);
        }
        Collections.sort(employeeList,new EmployeeIdDecendingOrder());
        System.out.println("After Sorting");
        for (Employee employee : employeeList) {
            System.out.println(employee);
        }
    }

    public static void main(String[] args) {
        processEmployeeList();
    }
}
package com.sapient.ds.collections;

public class Employee implements Comparable<Employee> {
    private int id;
    private String name;
    private double salary;

    public Employee() {

    }

    public Employee(int id, String name, double salary) {
        this.id = id;
        this.name = name;
        this.salary = salary;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", salary=" + salary +
                '}';
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }

    @Override
    public int compareTo(Employee employee) {
        return compare(this.id, employee.getId());
    }

    public int compare(int x, int y) {
        return (x < y) ? -1 : ((x == y) ? 0 : 1);
    }

}
............................................................................................

LinkedList:
package com.sapient.ds.collections;

import java.util.LinkedList;

public class LinkedListMain {
    public static void main(String[] args) {
        LinkedList<Integer> list = new LinkedList<>();
        list.add(1);
        list.add(2);
        list.add(3);
        list.addFirst(56);
        list.addLast(222);
        for (Integer value : list) {
            System.out.println(value);
        }
    }
}

Stack: Last In First Out:
..........................
package com.sapient.ds.collections;

import java.util.Stack;

public class StackMain {
    public static void main(String[] args) {
        Stack<Integer> integers = new Stack<>();
        integers.push(1);
        integers.push(3);
        integers.push(2); // l
        int vale = integers.pop(); // last value in the stack will be read
        System.out.println(vale);
    }
}
.............................................................................................

List order is index order(0th,1th...)
Linked list is insertion order(how you insert)
Stack is last in first Order
.............................................................................................
				  Set
..............................................................................................

A collection that contains no duplicate elements,like list only.

Set Implementation:

1.HashSet
2.LinkedHashSet
3.TreeSet


1.HashSet
 =>No duplicates
 =>order is element hashcode value.

public static void createHashSet() {
        Set<Integer> integerSet = new HashSet<>();
        integerSet.add(12);
        integerSet.add(12);
        integerSet.add(100);
        integerSet.add(1);
        for (Integer ins : integerSet) {
            System.out.println(ins);
        }
        Set<Employee> employeeHashSet = new HashSet<>();
        employeeHashSet.add(new Employee(1, "A1", 100.89));
        employeeHashSet.add(new Employee(3, "A3", 1070.89));
        employeeHashSet.add(new Employee(3, "A3", 1070.89));
        employeeHashSet.add(new Employee(2, "A2", 10330.89));
        employeeHashSet.add(new Employee(5, "A5", 10670.89));
        employeeHashSet.add(new Employee(5, "A5", 10670.89));

        for (Employee employee : employeeHashSet) {
            System.out.println(employee);
        }
    }

2.LinkedHashSet

LinkedList + Set

Order is insertion Order without duplicates

 public static void createLinkedHashSet() {
        Set<Integer> integerSet = new LinkedHashSet<>();
        integerSet.add(12);
        integerSet.add(12);
        integerSet.add(100);
        integerSet.add(1);
        for (Integer ins : integerSet) {
            System.out.println(ins);
        }
        Set<Employee> employeeHashSet = new LinkedHashSet<>();
        employeeHashSet.add(new Employee(1, "A1", 100.89));
        employeeHashSet.add(new Employee(3, "A3", 1070.89));
        employeeHashSet.add(new Employee(3, "A3", 1070.89));
        employeeHashSet.add(new Employee(2, "A2", 10330.89));
        employeeHashSet.add(new Employee(5, "A5", 10670.89));
        employeeHashSet.add(new Employee(5, "A5", 10670.89));

        for (Employee employee : employeeHashSet) {
            System.out.println(employee);
        }
    }
.............................................................................................
TreeSet:
=>It avoids duplicates 
=>The elements are ordered using their natural ordering of an element, or by a Comparator.
  integer-asy 
  integers-desc

 public static void createTreeSet() {
        Set<Integer> integerSet = new TreeSet<>();
        integerSet.add(12);
        integerSet.add(12);
        integerSet.add(100);
        integerSet.add(1);
        for (Integer ins : integerSet) {
            System.out.println(ins);
        }
        Set<Employee> employeeHashSet = new TreeSet<>(new EmployeeIdDecendingOrder());
        employeeHashSet.add(new Employee(1, "A1", 100.89));
        employeeHashSet.add(new Employee(3, "A3", 1070.89));
        employeeHashSet.add(new Employee(3, "A3", 1070.89));
        employeeHashSet.add(new Employee(2, "A2", 10330.89));
        employeeHashSet.add(new Employee(5, "A5", 10670.89));
        employeeHashSet.add(new Employee(5, "A5", 10670.89));

        for (Employee employee : employeeHashSet) {
            System.out.println(employee);
        }
    }


.............................................................................................
				  Map
.............................................................................................

Key-value Pair data Structure.

Map Implementation:
1.HashMap
   Storing values based key-value ,key order is hash value
2.LinkedHashMap
   Storing values based key-value ,key order is insertion order
3.TreeMap
  Storing values based key-value ,key order is based on Comparator or Comparable


package com.sapient.ds.collections;

import java.util.*;

public class MapImplementation {
    public static void main(String[] args) {
        //   createHashMap();
        //createLinkedHashMap();
        createTreeMap();
    }
    public static void createTreeMap() {
        Map<Integer, Integer> hash = new TreeMap<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer x, Integer y) {
                return  (x > y) ? -1 : ((x == y) ? 0 : 1);
            }
        });
        hash.put(1, 100);
        hash.put(4, 400);
        hash.put(5, 500);
        hash.put(3, 300);
        hash.put(2, 200);

        //convert map into set/Collection view for interation
        Set<Integer> keys = hash.keySet();
        for (Integer key : keys) {
            System.out.println(key);
        }
        Collection<Integer> values = hash.values();
        for (Integer value : values) {
            System.out.println(value);
        }
        for (Map.Entry<Integer, Integer> entry : hash.entrySet()) //using map.entrySet() for iteration
        {
            System.out.println("id: " + entry.getKey() + ", Value: " + entry.getValue());
        }
    }

    public static void createLinkedHashMap() {
        Map<Integer, Integer> hash = new LinkedHashMap<>();
        hash.put(1, 100);
        hash.put(4, 400);
        hash.put(5, 500);
        hash.put(3, 300);
        hash.put(2, 200);

        //convert map into set/Collection view for interation
        Set<Integer> keys = hash.keySet();
        for (Integer key : keys) {
            System.out.println(key);
        }
        Collection<Integer> values = hash.values();
        for (Integer value : values) {
            System.out.println(value);
        }
        for (Map.Entry<Integer, Integer> entry : hash.entrySet()) //using map.entrySet() for iteration
        {
            System.out.println("id: " + entry.getKey() + ", Value: " + entry.getValue());
        }
    }



    public static void createHashMap() {
        Map<Integer, Integer> hash = new HashMap<>();
        hash.put(1, 100);
        hash.put(4, 400);
        hash.put(5, 500);
        hash.put(3, 300);
        hash.put(2, 200);

        //convert map into set/Collection view for interation
        Set<Integer> keys = hash.keySet();
        for (Integer key : keys) {
            System.out.println(key);
        }
        Collection<Integer> values = hash.values();
        for (Integer value : values) {
            System.out.println(value);
        }
        for (Map.Entry<Integer, Integer> entry : hash.entrySet()) //using map.entrySet() for iteration
        {
            System.out.println("id: " + entry.getKey() + ", Value: " + entry.getValue());
        }


    }
}
..................................................................................
			Concurrency - Multi Threading
..................................................................................
	
package com.ibm.multithreading;

public class Task implements Runnable {
    @Override
    public void run() {
        //going to have thread logic
        System.out.println(Thread.currentThread().getName());

    }
}
package com.ibm.multithreading;

public class MulitThreadingMain {
    public static void main(String[] args) {
        //To know on which thread this current code is running
        System.out.println("Main method is Running on => " + Thread.currentThread().getName());

        //create new Thread
        for (int i = 0; i < 10; i++) {
            Thread thread = new Thread(new Task());
            thread.setName("Task-Thread-" + i);
            //start thread
            try {
                Thread.sleep(1000); //pause current thread for 1 sec
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            thread.start();
        }
    }
}
.....................................................................................
			  
.....................................................................................















































































	














